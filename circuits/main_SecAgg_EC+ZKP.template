pragma circom 2.1.0;

include "mod.circom";
include "mul.circom";
include "circomlib/circuits/pedersen.circom";
include "circomlib/circuits/babyjub.circom";

// Range proofs on each input, proof of Pedersen commitment to w_i, to s_i, to s_i (using other base), of product g^{w_i} * h^{s_i}
template EC_ZKP(n) {
	signal input in[n];
	signal input sk[n];
	signal output out_in[n][2];
	signal output out_cons[n][2];

	// Range checks	
	// LtConstantN((1<<8), n)(in);	// Range check for inputs

	// Encryption of inputs
	signal bits_in[n][250];
	signal bits_sk[n][250];
	signal tmp[n][2];
	signal tmp2[n][2];
	// OPTIMIZATION: skip range check and use bit-decomp instead? Or at least reuse bit-decomp?
	for (var i = 0; i < n; i++) {
	    bits_in[i] <== Num2Bits(250)(in[i]);
	    bits_sk[i] <== Num2Bits(250)(sk[i]);

	    var pedersen_in[250*2];
	    for (var j = 0; j < 250; j++) {
	        pedersen_in[j] = bits_in[i][j];
	        pedersen_in[250+j] = bits_sk[i][j];
	    }
	    out_in[i] <== Pedersen(250*2)(pedersen_in);

	     var pedersen_in2[250*2];
         for (var j = 0; j < 250; j++) {
            pedersen_in2[j] = bits_sk[i][j];
            pedersen_in2[250+j] = 0;
        }
        out_cons[i] <== Pedersen(250*2)(pedersen_in2);
	}
}

component main = EC_ZKP(N);
