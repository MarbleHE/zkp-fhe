pragma circom 2.1.0;

include "mod.circom";
include "mul.circom";

template BenchMedium(l, n, t, q1, q2, q3) {
	// Compute ModSwitch(Mul((in - w), (in - w))), where in is a ciphertext (in NTT form), and w is a plaintext server inputs.
	// No relinearization is carried out, but a modulus switching is performed to reduce the size of the output.
	// This is similar to the computation performed in ORide [PDETHH17](https://www.usenix.org/system/files/conference/usenixsecurity17/sec17-pham.pdf).
	signal input in[2][l][n]; 
	signal input w[n];
	signal diff[2][l][n];
	signal mul[3][l][n];
	signal output out[3][n];
	
	// Range check for plaintext inputs
	LtConstantN(t, n)(w);

	var q[L]; 
	assert(0 < L && L <= 3);
	if (L == 1) {q = [q1]; }
	if (L == 2) {q = [q2]; }
	if (L == 3) {q = [q3]; }

	// diff = Sub(in, w)
	for (var i = 0; i < l; i++) {
		// OPTIMIZATION: if t < q[i], there's no need to reduce w modulo q[i] for each CRT component
		assert(t < q[i]);
		for (var j = 0; j < n; j++) {
			diff[0][i][j] <== parallel FastSubMod(q[i])([in[0][i][j], w[j]]);
		}
	}
	diff[1] <== in[1];

	// mul = Mul(diff, diff)
	mul <== parallel SquareCtxt(l, n, q1, q2, q3)(diff);
	
	// out = ModSwitchToLast(mul)
	// OPTIMIZATION: Since we are in CRT representation, we can simply set all higher moduli to zero and only take the first modulus
	// We don't bother to have zero outputs for efficiency
	for (var j = 0; j < n; j++) {
		out[0][j] <== mul[0][0][j];
		out[1][j] <== mul[1][0][j];
		out[2][j] <== mul[2][0][j];
	}
}

component main {public [in]} = BenchMedium(L, N, T, Q1, Q2, Q3);
